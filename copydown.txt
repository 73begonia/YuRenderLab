void procCameraInp(InpState inp, vec2 res, float md, vec2 angles, vec2 dragAngles, vec2 dragStart,
                   vec3 camPos, vec3 camDir, sampler2D, sampler2D buf, inout IxResult r)
{
    if (md == MODE_CAMERA)
    {
        if (inp.mdown)
        {
            vec2 delta = inp.mpos - dragStart;
            vec2 newAng;
            newAng.y = dragAngles.y - delta.x / res.x * CAM_SENS_X;
            newAng.x = clamp(dragAngles.x + delta.y / res.y * CAM_SENS_Y, -PI * 0.49, PI * 0.49);

            r.flags = r.flags | CHG_CAMERA;
            r.angles = newAng;
            r.camDir = angles2dir(newAng);
            r.camPos = camPos;
            r.dragStart = dragStart;
            r.dragAngles = dragAngles;
        }
        return;
    }

    if (imp.mpressed)
    {
        r.flags = r.flags | CHG_SELECTION | CHG_CAMERA;
        r.imode = MODE_CAMERA;
        r.dragStart = inp.mpos;
        r.dragAngles = angles;
        r.camPos = camPos;
        r.camDir = camDir;
        r.angles = angles;
    }
}

void procCameraMove(InpState inp, vec3 camPos, vec3 camDir, vec2 angles, sampler2D kb, sampler2D buf, inout IxResult r)
{
    float spd = CAM_SPEED;
    if (inp.kshift) spd *= CAM_SPRINT;

    vec3 fwd = normalize(camDir);
    vec3 rt = normalize(cross(fwd, vec3(0.0, 1.0, 0.0)));
    if (length(cross(fwd, vec3(0.0, 1.0, 0.0))) < 0.001)
    {
        rt = vec3(1.0, 0.0, 0.0);
    }

    vec3 newPos = camPos;
    bool moved = false;

    if (keyDown(kb, KEY_W)) { newPos = newPos + fwd * spd; moved = true; }
    if (keyDown(kb, KEY_S)) { newPos = newPos - fwd * spd; moved = true; }
    if (keyDown(kb, KEY_A)) { newPos = newPos - rt * spd; moved = true; }
    if (keyDown(kb, KEY_D)) { newPos = newPos + rt * spd; moved = true; }
    if (keyDown(kb, KEY_SPACE)) { newPos.y = newPos.y + spd; moved = true; }
    if (keyDown(kb, KEY_CTRL)) { newPos.y = newPos.y - spd; moved = true; }

    if (moved)
    {
        r.flags = r.flags | CHG_CAMERA;
        r.camPos = newPos;
        r.camDir = camDir;
        r.angles = angles;
        r.dragStart = ld(buf, 0, ROW_CAMERA).xy;
        r.dragAngles = ld(buf, 1, ROW_CAMERA).zw;
    }
}

IxResult processInteraction(InpState inp, vec4 mouse, vec2 res, int frame, sampler2D buf, sampler2D kb)
{
    IxResult r = initIxResult();

    vec4 mouseState = ld(buf, 0, ROW_CAMERA);
    vec4 anglesData = ld(buf, 1, ROW_CAMERA);
    vec3 camDir = ld(buf, 2, ROW_CAMERA).xyz;
    vec3 camPos = ld(buf, 3, ROW_CAMERA).xyz;
    vec4 stateData = ld(buf, 0, ROW_STATE);

    float md = stateData.x;
    vec2 angles = anglesData.xy;
    vec2 dragAngles = anglesData.zw;
    vec2 dragStart = mouseState.xy;

    if (length(camDir) < 0.001) 
    {
        camDir = CAM_INIT_DIR;
    }

    procCameraMove(inp, camPos, camDir, angles, kb, buf, r);

    if ((r.flags & CHG_CAMERA) != 0u)
    {
        camPos = r.camPos;
    }

    if (inp.mreleased)
    {
        if (md == MODE_CAMERA)
        {
            r.flags = r.flags | CHG_CAMERA;
            r.camPos = camPos;
            r.camDir = camDir;
            r.angles = angles;
            r.dragStart = dragStart;
            r.dragAngles = angles;
        }
        r.flags = r.flags | CHG_SELECTION;
        r.imode = MODE_NONE;
        return r;
    }

    procCameraInp(inp, res, md, angles, dragAngles, dragStart, camPos, camDir, kb, buf, r);

    return r;
}

vec4 initState(ivec2 px, vec2 res)
{
    if (px.y == ROW_CAMERA)
    {
        if (px.x == 0) return vec4(0.0);
        if (px.x == 1) return vec4(0.0, 0.0, 0.0, 0.0);
        if (px.x == 2) return vec4(CAM_INIT_DIR, 0.0);
        if (px.x == 3) return vec4(CAM_INIT_POS, 0.0);
    }
    if (px.y == ROW_STATE && px.x == 0)
    {
        return vec4(MODE_NONE, 0.0, 0.0, 0.0);
    }
    return vec4(0.0);
}

vec4 applyIxResult(ivec2 px, IxResult r, InpState inp, sampler2D buf)
{
    if (px.y == ROW_CAMERA)
    {
        vec4 oldMouse = ld(buf, 0, ROW_CAMERA);
        vec4 oldAngs = ld(buf, 1, ROW_CAMERA);
        vec4 oldDir = ld(buf, 2, ROW_CAMERA);
        vec4 oldPos = ld(buf, 3, ROW_CAMERA);

        if (px.x == 0)
        {
            vec2 ds = (r.flags & CHG_CAMERA) != 0u ? r.dragStart : oldMouse.xy;
            return vec4(ds, inp.mdown ? 1.0 : 0.0, 0.0);
        }
        if (px.x == 1)
        {
            vec2 angs = (r.flags & CHG_CAMERA) != 0u ? r.angles : oldAngs.xy;
            vec2 dAngs = (r.flags & CHG_CAMERA) != 0u ? r.dragAngles : oldAngs.zw;
            return vec4(angs, dAngs);
        }
        if (px.x == 2)
        {
            vec3 dir = (r.flags & CHG_CAMERA) != 0u ? r.camDir : oldDir.xyz;
            return vec4(dir, 0.0);
        }
        if (px.x == 3)
        {
            vec3 pos = (r.flags & CHG_CAMERA) != 0u ? r.camPos : oldPos.xyz;
            return vec4(pos, 0.0);
        }
    }

    if (px.y == ROW_STATE && px.x == 0)
    {
        if ((r.flags & CHG_SELECTION) != 0u)
        {
            return vec4(r.imode, 0.0, 0.0, 0.0);
        }
        return ld(buf, 0, ROW_STATE);
    }

    return vec4(0.0);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    ivec2 px = ivec2(fragCoord);
    vec2 res = iResolution.xy;

    if (px.y > ROW_KEYS)
    {
        fragColor = vec4(0.0);
        return;
    }

    if (iFrame == 0)
    {
        fragColor = initState(px, res);
        return;
    }

    vec4 mouseState = ld(iChannel0, 0, ROW_CAMERA);
    float prevDown = mouseState.z;

    InpState inp = gatherInp(iKeyboard, iMouse, prevDown);

    IxResult r = processInteraction(inp, iMouse, res, iFrame, iChannel0, iKeyboard);

    fragColor = applyIxResult(px, r, inp, iChannel0);
}